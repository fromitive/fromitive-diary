---
title: "알면 좋은 교양 - 다형성"
description: "다형성의 다양한 원리들"
time: 2024-01-09 20:54:45
tags:
  - software-engineering
---

## 다형성이란 무엇인가?

다형성이란 객체들의 관계가 있을 경우, 해당 객체의 데이터 형을 자유롭게 변화할 수 있는 성질이라고 생각한다. 아래는 다형성의 정의이다.

> polymorphism is the use of a single symbol to represent multiple different types. -위키디피아-

다형성을 이용하면 좋은점은 정적인 자료형과 다르게 유연하고 확장 가능한 설계가 가능하다는 점이다.

## 상속의 진짜 목적

상속은 어떻게 보면 class를 확장하여 다른 메소드를 지원하거나, 다른 타입의 자료를 추가로 확장하는 것처럼 보인다. <<오브젝트>>에서는 바로 이러한 부분이 객체지향의 오해가 생긴 부분이라고 한다.

진정한 상속의 목적은 **타입 계층을 만드는 데에 있다.**

다형성의 정의를 설명할 때, 객체들의 관계가 있어야 한다고 했던말 기억하는가? 만약 A와 B에 아무런 연관 관계가 없으면 다형성을 활용하지 못할 수 있지만, 상속 및 인터페이스 구현과 같이 객체끼리의 관계를 지정하게 된다면 다형성을 활용할 수 있다. 타입 계층이란 그러한 관계를 만드는 것이다.

## 업케스팅과 동적 바인딩

### 업케스팅

상속을 제대로 알기 위해서는 업케스팅과 동적 바인딩의 원리를 알아야 한다. 

**업케스팅** 이란, 상속의 관계가 있는 객체가 있을 때, 자식이 부모의 타입으로 변환하는 성질로 볼 수 있다.

예로 들어, `Lecture` 및 `GradeLecture` 객체가 있다고 하자. 둘의 관계는 부모와 자식간의 관계를 이룬다. 아래와 같은 예제가 있을때 컴파일오류가 날까?

``` java
void check(Lecture lecture) {
    return lecture.something();
}
var lecture = new GradeLecture();
check(lecture); // 컴파일 오류가 날까?
```

결론부터 말하자면 컴파일 에러가 나지 않는다. java 언어는 업케스팅이 지원되기 때문에 자식 클래스가 부모 클래스의 메소드를 호출할 수 있기 때문이다. 이런 일이 가능한 이유는 동적 바인딩의 원리를 알아야 한다.

### 동적 바인딩

java는 컴파일 시점의 의존성과, 런타임 시점의 의존성이 다르다는 말을 들어봤을 것이다. 그 이유는 java가 동적 바인딩 기술을 이용하기 때문이다. 동적 바인딩이란, 런타임 시점에 업케스팅으로 인한해 부모 클래스가 지원하는 메소드(예제에서 , lecture.somthing() 부분) 함수를 호출 할 때, 실제 `something()`의 루틴을 동적으로 찾아내어 준다. 즉, somthing() 메소드를 런타임에 호출하게 되면, `GradeLecture`에 오버라이딩 된 sometihng()을 호출을 한다. 그러나, 오버라이딩이 되어 있지 않다면 `Lecture`안의 something()을 호출한다. 둘 사이의 메소드를 찾는 방식은 일종의 규칙이 있다. 규칙은 아래와 같다. 이 규칙은 언어마다 다르다고 하나, 보통 아래와 같은 형태로 이루어 진다.

``` title="동적 바인딩 순서"
1. 자신에게 something()이 있다면 그걸 호출해라.

2. 부모 클래스의 somthing()에 있다면 그걸 호출해라.

3. 부모의 부모 ...

4. Object에 something()이 있다면 그걸 호출해라.

5. 예외 발생!
```

위의 예제는 실제 인스턴스는 `GradeLecture`이기 때문에 아무리 업케스팅이 이루어 졌다해도 해당 객체에 정의된 `something()`을 우선적으로 처리해주기 때문에, 결론적으로 동적 바인딩으로 인한 컴파일 시점과 실행 시점의 의존성이 달라지는 결과를 얻게 된다. **이는 프로그램의 동작 분석을 어렵게 만드나, 유연하고, 결합도가 낮은 프로그램을 만들 수 있게 해주는 기술의 핵심이다.**

## 오버로딩과 오버라이딩의 차이

오버로딩과 오버라이딩의 차이를 면접 때나, 학교 시험에 많이 질문을 받기도 하였다. 지금은 어떤지는 모르겠으나, 현재 시점에서 답변을 하자면 오버로딩이란, 상속 관계 혹은 같은 객체안에서 메소드 이름은 같지만 시그니처가 다를경우를 메소드 오버로딩이라고 하고, 이름도 같고, 시그니처가 같으면 메소드 오버라이딩이 발생하게 된다. 시그니처란, 받는 매개변수와 함수의 이름을 합한 것을 의미한다.

위의 동적 바인딩을 좀 더 자세히 설명하자면 자신이 가지고 있는 시그니처를 탐색하고, 없다면 부모클래스에서 시그니처를 탐색하는 원리로 적절한 메소드를 찾게 된다.

그렇다면 자신은 어떻게 표현하는지 궁금할 것이다. 그에대한 답변은 다음 항목을 살펴보자.

## object의 숨겨진 포인터 self와 super

객체를 만들게 되면 보이지는 않지만 기본적으로 할당되는 포인터가 있다. 이를 `self` 포인터라고 한다. 위에서 말하는 자기자신이란 이 `self` 포인터를 의미한다. java에서는 `this`로 나타내며 주로, 생성자에서 맴버 변수를 설정할 때 많이 사용했을 것이다. 이 self 포인터를 통해 동적 바인딩시 첫번째로 메소드를 탐색하게 된다. 즉, **self가 동적 바인딩의 시작점으로 보면 된다.**

부모 클래스를 호출할 때, **super**를 사용하게 되는데 이는, self 위의 상위 객체를 불러올 때 사용된다. 보통, 부모 객체의 메소드나, 부모 안의 맴버변수를 초기화 할 때 쓰이지만, 무조건 부모 객체를 가리키지는 않는다고 한다. 스칼라 언어에서는 `trait`을 지원하는데, 만약 trait을 지정하게 된다면 super는 trait을 가리키게 된다고 한다. 

## delegation(위임) 과 forwarding

delegation이란 `self`나 `super`를 통해서 매게변수를 그대로 전달하는 행위로 보면 된다. 이와 다르게 forwarding은 함수안에 다른 함수에 매게변수를 그대로 전달하는 행위를 이야기하는 것으로(?) 이해했다. wrapper를 사용할때 사용되는 것 같다.   

## 객체의 메소드와 일반 함수의 차이

상황에 따라 메소드와 일반 함수를 혼용해서 쓰이곤 했다. 하지만, 동적 바인딩 개념을 아는 이상 메소드와 일반 함수의 차이가 눈에 보인다.

일반 함수는 컴파일 시점에 해당 함수의 시작 위치를 알 수 있다. 이를 정적 바인딩이라고 한다. 실행 시점과 컴파일 시점의 실행 위치가 같은 것이 특징이고 프로그램의 흐름이 예측가능하다.

메소드는 객체에 전달하는 메시지로서, 컴파일 시점과 런타임 시점의 실행 위치를 알 수 없다. `Lecture.somthing()`은 `Lecture`에 있는 `somthing`이 호출될까? 아니면 `GradeLecture` `something`이 호출될까? 이처럼 동적 바인딩이 이루어지는 루틴이므로 실행 위치를 명확하게 알 수 없고 프로그램 흐름을 예측하지 못하게 된다.

둘 다, 하나의 루틴을 수행하는 역할을 하지만 큰 차이점은 실행 시점과 컴파일 시점의 차이에서 나타나게 된다.

## class 없이 다형성 구현

class의 상속 없이 다형성을 만들 수 있다고 한다. javascript에서는 각 객체마다 prototype 변수를 갖는데, 이를 이용해 객체간 관계를 설정할 수 있다고 한다. 자세한 내용은 MDN에 있다.

* 링크 : [상속과 프로토타입 - Mdn Web Docs](https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) 



